# 06 컴포넌트 반복

반복되는 코드를 만들게 되는 경우가 있음.

```javascript
// IterationSample.js

const IterationSample = () => {
    return (
    	<ul>
        	<li>눈사람</li>
        	<li>얼음</li>
        	<li>눈<li>
        	<li>바람</li>
        </ul>
    );
};

export default IterationSample;
```

리액트 프로젝트에서 반복적인 내용을 효율적으로 보여주고 관리하는 방법을 알아보자.

## 6.1 자바스크립트 배열의 map() 함수

자바스크립트 배열 객체의 내장 함수인 map 함수를 사용하여 반복되는 컴포넌트를 렌더링할 수 있습니다. map 함수는 파라미터로 전달된 함수를 사용해 배열 내 각 요소를 원하는 규칙에 따라 변환한 후 그 결과 새로운 배열을 생성합니다.

### 6.1.1 문법

`arr.map(callback, [thisArg])`

- `callback` : 새로운 배열의 요소를 생성하는 함수로 파라미터는 다음 세 가지입니다.
  - `currentValue` : 현재 처리하고 있는 요소
  - `index` : 현재 처리하고 있는 요소의 index 값
  - `array` : 현재 처리하고 있는 원본 배열
- `thisArg`(선택 항목) : callback 함수 내부에서 사용할 this 레퍼런스

### 6.1.2 예제

:question: map함수를 사용하여 배열 [1, 2, 3, 4, 5]의 각 요소를 제곱해서 새로운 배열을 생성

```javascript
var numbers = [1, 2, 3, 4, 5];
var processed = numbers.map(function (num) {
  return num * num;
});

console.log(processed);
```

![image-20230414161521935](/img/06/image-20230414161521935.png)

:arrow_forward: map 함수는 기존 배열로 새로운 배열 만드는 역할을 함.

**ES6 문법으로**

```javascript
const numbers = [1, 2, 3, 4, 5];
const result = numbers.map((num) => num * num);
console.log(result);
```

### 6.4.2 데이터 추가 기능 구현하기

`onClick` 함수에서는 배열의 내장 함수 `concat` 을 사용하여 새로운 항목을 추가한 배열을 만들고, `setNames` 를 통해 상태를 업데이트한다.

```jsx
import { useState } from "react";

const IterationSample = () => {
  const [names, setNames] = useState([
    { id: 1, text: "눈사람" },
    { id: 2, text: "얼음" },
    { id: 3, text: "눈" },
    { id: 4, text: "바람" },
  ]);
  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(5);

  const onChange = (e) => setInputText(e.target.value);

  const onClick = () => {
    const nextNames = names.concat({
      id: nextId,
      text: inputText,
    });
    setNextId(nextId + 1); //	nextId 값에 1을 더해 준다.
    setNames(nextNames); // 	concat을 통해 새로운 항목이 추가된 배열로 업데이트.
    setInputText(""); //	inputText 비운다.
  };

  const namesList = names.map((name) => <li key={name.id}>{name.text}</li>);
  return (
    <>
      <input value={inputText} onChange={onChange} />
      <button onClick={onClick}>추가</button>
      <ul>{namesList}</ul>;
    </>
  );
};

export default IterationSample;
```

배열에 새 항목을 추가할 때 `push`함수를 사용하지 않고 `concat`을 사용했는데,

- `push` 함수는 기존 배열 자체를 변경해 주고,
- `concat` 함수는 새로운 배열을 만들어 준다 는 차이점이 있다.

리액트에서 상태를 업데이트할 때는 기존 상태를 그대로 두면서 새로운 값을 상태로 설정해야 하는 <u>**불변성 유지**</u> 를 해 주어야 리액트 컴포넌트의 성능을 최적화할 수 있다.

##### [그림6-5 데이터 추가 기능 완성]

![그림6-5](/img/06/그림6-5.JPG)

### 6.4.3 데이터 제거 기능 구현하기

불변성을 유지하면서 배열의 특정 항목을 지울 때는 배열의 내장 함수 `filter` 를 사용한다.

##### [filter 함수 예제]

```javascript
const numbers = [1, 2, 3, 4, 5, 6];
const biggerThanThree = numbers.filter((number) => number > 3);
// 결과: [4, 5, 6]

const numbers = [1, 2, 3, 4, 5, 6];
const withoutThree = numbers.filter((number) => number !== 3);
// 결과: [1, 2, 4, 5, 6]
```

항목을 더블클릭했을 때 제거 되는 기능을 구현해보자.

```jsx
import { useState } from "react";

const IterationSample = () => {
  const [names, setNames] = useState([
    { id: 1, text: "눈사람" },
    { id: 2, text: "얼음" },
    { id: 3, text: "눈" },
    { id: 4, text: "바람" },
  ]);
  const [inputText, setInputText] = useState("");
  const [nextId, setNextId] = useState(5);

  const onChange = (e) => setInputText(e.target.value);

  const onClick = () => {
    const nextNames = names.concat({
      id: nextId,
      text: inputText,
    });
    setNextId(nextId + 1);
    setNames(nextNames);
    setInputText("");
  };

  const onRemove = (id) => {
    const nextNames = names.filter((name) => name.id !== id);
    setNames(nextNames);
  };

  const namesList = names.map((name) => (
    <li key={name.id} onDoubleClick={() => onRemove(name.id)}>
      {name.text}
    </li>
  ));
  return (
    <>
      <input value={inputText} onChange={onChange} />
      <button onClick={onClick}>추가</button>
      <ul>{namesList}</ul>;
    </>
  );
};

export default IterationSample;
```

더블클릭 이벤트(onDoubleClick)를 통해 해당 리스트를 삭제할 수 있다.

##### [그림6-6 데이터 제거 기능 완성]

![그림6-6](/img/06/그림6-6.JPG)
