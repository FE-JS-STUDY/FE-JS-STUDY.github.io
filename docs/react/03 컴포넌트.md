### 3.4.1 state 객체 안에 여러 값이 있을 때

state 객체 안에는 여러 값이 있을 수 있다.

```javascript
import { Component } from "react";

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      number: 0,
      fixedNumber: 0
    };
  }
  render() {
    const { number, fixedNumber } = this.state;
    return (
      <div>
        <h1>{number}</h1>
        <h2>바뀌지 않는 값: { fixedNumber }</h2>
        <button
          onClick={() => {
            this.setState({ number: number + 1 });
          }}
        >
          +1
        </button>
      </div>
    );
  }
}

export default Counter;
```

`state`에 fixedNumber 값을 추가해도 `this.setState` 함수는 인자로 전달된 객체 안에 있는 값만 바꾼다 => <u>버튼을 눌러도fixedNumber 값은 0으로 고정된다.</u>

### 3.4.1.2 state를 constructor에서 꺼내기

state의 초깃값을 지정하기 위해 `constructor`메서드를 선언해 주었는데 다른 방법으로도 지정 가능하다.

```javascript
class Counter extends Component {
  state = {
    number: 0,
    fixedNumber: 0,
  };
  render() {...}
```

### 3.4.1.3 this.setState에 객체 대신 함수 인자 전달하기

`this.setState`를 사용하여 state 값을 업데이트할 때는 상태가 비동기적으로 업데이트된다.

```javascript
<button
	onClick={() => {
    this.setState({ number: number + 1 });
    this.setState({ number: this.state.number + 1 });
	}}
>
```

`this.setState`를 두 번 사용해도 버튼을 클릭하면 1씩 증가한다. => `this.setState`를 사용해도 state 값이 바로 바뀌지 않기 때문

`this.setState`를 사용할 때 객체 대신에 함수를 인자로 넣어 주는 것으로 해결 가능하다.

```javascript
this.setState(( prevState, porps ) => {
    return {
        // 업데이트하고 싶은 내용
    }
}) 
```

**prevState는 기존 상태이고, props는 현재 지니고 있는 props를 가리킨다. props가 필요하지 않다면 생략 가능하다.**

```javascript
<button
    onClick={() => {
        this.setState((prevState) => {
            return {
                number: prevState.number + 1,
            };
        });
        // 함수에서 바로 객체를 반환하는 코드
        this.setState((prevState) => ({
            number: prevState.number + 1,
        }));
    }}
>
```

### 3.4.1.4 this.setState가 끝난 후 특정 작업 실행하기

`setState`를 사용하여 값을 업데이트하고 난 다음에 특정 작업을 하고 싶을 때는 `setState`의 두 번째 파라미터로 콜백 함수를 등록하여 작업을 처리할 수 잇다.

```javascript
<button
    onClick={() => {
        this.setState(
            {
                number: number + 1,
            },
            () => {
                console.log("방금 setState가 호출되었습니다.");
            }
        );
    }}
>
```

### 3.4.2 함수 컴포넌트에서 useState 사용하기

리액트 16.8 이전 버전에서는 함수 컴포넌트에서 state를 사용할 수 없었다. 하지만 16.8 이후부터 Hooks을 통해 state를 사용할 수 있게 되었다.

### 3.4.2.1 배열 비구조화 할당

배열 비구조화 할당이란 배열 안에 들어 있는 값을 쉽게 추출할 수 있도록 하는 문법이다.

```javascript
const array = [1, 2]
const one = array[0]
const two = array[1]

---------------------------------------
// 배열 비구조화 할당 사용
const array = [1, 2]
const [one, two] = array
```

### 3.4.2.2 useState 사용하기

```javascript
import { useState } from "react";

const Say = () => {
  const [message, setMessage] = useState("");
  const onClickEnter = () => setMessage("안녕하세요!");
  const onClickLeave = () => setMessage("안녕히 가세요!");

  return (
    <div>
      <button onClick={onClickEnter}>입장</button>
      <button onClick={onClickLeave}>퇴장</button>
      <h1>{message}</h1>
    </div>
  );
};

export default Say;
```

`useState` 함수의 인자에는 상태의 초깃값을 넣어 준다. 클래스형 컴포넌트에서의 state 초깃값은 객체 형태를 넣어야 하지만 `useState`에서는 객체가 아니어도 됨.

함수를 호출하면 배열이 반환되는데, 배열의 첫 번째 원소는 현재 상태이고 두 번째 원소는 상태를 바꾸어 주는 함수로 Setter 함수라고 부른다.

### 3.4.2.3 한 컴포넌트에서 useState 여러 번 사용하기

useState는 한 컴포넌트에서 여러 번 사용해도 상관없다.

```javascript
import { useState } from "react";

const Say = () => {
  const [message, setMessage] = useState("");
  const onClickEnter = () => setMessage("안녕하세요!");
  const onClickLeave = () => setMessage("안녕히 가세요!");

  const [color, setColor] = useState("black");

  return (
    <div>
      <button onClick={onClickEnter}>입장</button>
      <button onClick={onClickLeave}>퇴장</button>
      <h1 style={{ color }}>{message}</h1>
      <button style={{ color: "red" }} onClick={() => setColor("red")}>
        빨간색
      </button>
      <button style={{ color: "green" }} onClick={() => setColor("green")}>
        초록색
      </button>
      <button style={{ color: "blue" }} onClick={() => setColor("blue")}>
        파란색
      </button>
    </div>
  );
};

export default Say;
```

### 3.5 state를 사용할 때 주의 사항

state값을 바꾸어야 할 때는 `setState` 혹은 `useState`를 통해 전달받은 세터 함수를 사용해야 한다.

##### - 잘못된 코드 -

```javascript
// 클래스형 컴포넌트
this.state.number = this.state.number + 1
this.state.array = this.state.push(2)
this.state.object.value = 5

// 함수 컴포넌트
const [object, setObject] = useState({ a: 1, b: 1 })
object.b = 2
```

배열이나 객체를 업데이트해야 할 때 사본을 만들고 그 사본에 값을 업데이트한 후, 사본의 상태를 `setState` 혹은 세터 함수를 통해 업데이트한다.

```javascript
// 객체 다루기
const object = { a: 1, b: 2, c: 3 }
cont nextObject = { ...object, b: 2 }			//	사본을 만들어서 b 값만 덮어 쓰기

// 배열 다루기
const array = [
    { id: 1, value: true },
    { id: 2, value: true },
    { id: 3, value: false }
]
let nextArray = array.concat({ id: 4 })			//	새 항목 추가
nextArray.filter(item => item.id !== 2) 		//	id가 2인 항목 제거
nextArray.map(item => item.id === 1 ? { ...item, value: false } : item))		//	id가 1인 항목의 value를 false로 설정
```

객체에 대한 사본을 만들 때는 `spread` 연산자라 불리는 ... 을 사용하여 처리하고, 배열에 대한 사본을 만들 때는 배열의 내장 함수들을 활용한다.