# 04 콜백 함수





### 4-2-3 this

> 콜백 함수도 함수이기 때문에 기본적으로는 this가 전역객체를 참조하지만, 제어권을 넘겨받을 코드에서 콜백 함수에 별도로 this가 될 대상을 지정한 경우에는 그 대상을 참조하게 된다.

**예제 4-5 콜백 함수 예제(2-3) Array.prototype.map - 구현**

```javascript
Array.prototype.map = function (callback, thisArg) {
	var mappedArr = [];
	for (var i = 0; i < this.length; i++) {
		var mappedValue = callback.call(thisArg || window, this[i], i, this);
		mappedArr[i] = mappedValue;
	}
	return mappedArr;
};
```

**call/apply 메서드**

`call(thisArg || window, this[i], i, this);`

- this에 지정할 값 : thisArg가 있으면 그 값을, 없으면 전역객체 지정
- 첫 번째 인자 : 매서드의 this가 배열 가리킬 것이므로 배열의 i번째 요소 값
- 두 번째 인자 : index
- 세 번째 인자 : 배열 자체

⇒ this에 다른 값이 담기는 이유 : 제어권을 넘겨받을 코드에서 call/apply 메서드의 첫 번째 인자에 콜백 함수 내부에서의 this가 될 대상을 명시적으로 바인딩하기 때문



**예제 4-6 콜백 함수 내부에서의 this**

```javascript
setTimeout(function () { console.log(this)}, 300); 	// (1) Window { ... }

[1, 2, 3, 4, 5].forEach(function (x) {
	console.log(this);								// (2) Window { ... }
})

document.body.innerHTML += '<button id="a">클릭</button>';
document.body.querySelector('#a').addEventListener('click', function (e){
	console.log(this, e);							// (3) <button id="a">클릭</button>
	}												// PoinerEvent { isTrusted: true, ... }
);
```

(1) `setTimeout`은 내부에서 콜백함수 호출시 call 메서드의 첫 번째 인자에 전역객체 넘김

(2) `forEach`는 별도의 인자로 this를 받는 경우에 해당하지만 별도의 인자를 넘겨주지 않았기 때문에 전역객체 가리킴

(3) `addEventListener`는 내부에서 콜백 함수를 호출할 때 call 메서드의 첫 번째 인자에 `addEventListener`메서드의 this를 그대로 넘기도록 정의돼 있기 때문에 콜백 함수 내부에서의 this가 호출한 주체인 html 엘리먼트를 가리키게 됨.



## 4-3 콜백 함수는 함수다

> 콜백 함수는 함수입니다.
> 콜백 함수로 어떤 객체의 메서드를 전달하더라도 그 메서드는 메서드가 아닌 **함수**로서 호출됩니다.

**예제 4-7 메서드를 콜백 함수로 전달한 경우**

```javascript
var obj = {
	vals : [1, 2, 3],
	logValues: function(v, i) {
		console.log(this, v, i);
	}
};
obj.logValues(1, 2);				// (1) {vals: [1, 2, 3], logValues: ƒ} 1 2
[4, 5, 6].forEach(obj.logValues);	// (2) Window { ... } 4 0
									// Window { ... } 5 1
									// Window { ... } 6 2
```

(1) `obj.logValues(1, 2)` : 메서드로 호출했으므로 this는 점 앞의 obj를 가리킴

(2) `[4, 5, 6].forEach(obj.logValues)` : `forEach`의 콜백 함수로 `obj.logValues`가 가리키는 함수가 전달됨.(즉 함수)



## 4-4 콜백 함수 내부의 this에 다른 값 바인딩하기

> 콜백 함수 내부에서 this가 객체를 바라보게 하고 싶다면?

**예제 4-8 ① 전통적인 방식 - 변수 활용**

```javascript
var obj1 = {
	name: 'obj1',
	func: function () {
		var self = this;
		return function () {
			console.log(self.name);
		};
	}
};
var callback = obj1.func();		// (1)
setTimeout(callback, 1000);		// obj1
```

(1) `obj1.func()` 메서드 내부에서 self 변수에 this를 담고 익명함수를 선언과 동시에 반환

 `obj1.func()` 를 호출하면서 앞서 선언한 내부함수가 반환됨

(2) callback 함수 실행시 obj1 반환

⇒ this를 사용하지 않고, 번거로움. this를 안 쓰는 게 나을 것

**예제 4-9 ② 콜백 함수에서 this를 사용하지 않는 경우**

```javascript
var obj1 = {
	name: 'obj1',
	func: function () {
		console.log(obj1.name);
	}
};
setTimeout(obj1.func, 1000);		// obj1
```

⇒ this를 재활용할 수 없음

**예제 4-10 ③ 4-8의 func 재활용**

```javascript
...					// 예제 4-8 부분 

var obj2 = {
	name: 'obj2',
	func: obj1.func
};
var callback2 = obj2.func();
setTimeout(callback2, 1500);			// (1) obj2

var obj3 = { name: 'obj3'};
var callback3 = obj1.func.call(obj3);
setTimeout(callback3, 2000)				// (2) obj3
```

(1) `callback2` : `obj1`의 `func`을 복사한 `obj2`의 `func`을 실행한 결과를 담아 이를 콜백으로 활용

(2) `callback3` : `obj3`을 this로 지정

**예제 4-11 ④ bind 메서드 활용**

```javascript
var obj1 = {
	name: 'obj1',
	func: function () {
		console.log(this.name)
	}
};
setTimeout(obj1.func.bind(obj1), 1000);		// obj1

var obj2 = { name : 'obj2' };
setTimeout(obj1.func.bind(obj2), 1500); 	// obj2
```

