# 14 타입 가드

## 14.1 타입 가드란?

- 여러 개의 타입으로 지정된 값을 특정 위치에서 원하는 타입으로 구분하는 것

- 타입 시스템 관점에서 넓은 타입에서 좁은 타입으로 범위를 좁히는 것
- 여러 타입이 있을 때 내가 원하는 타입을 뽑기 위해 다른 타입을 막는 것(가드)

![image-20231107144239823](/img/typescript/14/image-20231107144239823.png)

```typescript
function updateInput(textInput: number | string | boolean) {
    // 타입 가드
    if (type of textInput === 'number') {
        textInput
    }
}
```

- if문이 타입 가드 역할을 함 : if문 안에서 `textInput` 파라미터는 `number` 타입으로만 간주됨

- `textInput`의 파라미터 타입이 `number`이기 때문에 `number` 타입이 제공하는 API를 자동완성으로 확인 가능



## 14.2 왜 타입 가드가 필요할까?

```typescript
function updateInput(textInput: number | string | boolean) {
    textInput.toFixed(2);  // 에러
}
```

`textInput` 파라미터가 유니언 타입이기 때문에 `number` 타입 API인 `toFixed()`를 사용하면 에러가 발생함 (6.3 참조)

### 14.2.1 타입 단언으로 타입 에러 해결하기

```typescript
function updateInput(textInput: number | string | boolean) {
    (textInput as number).toFixed(2);
}
```

### 14.2.2 타입 단언으로 해결했을 때 문제점

**1. 실행 시점의 에러는 막을 수 없다**

```typescript
function updateInput(textInput: number | string | boolean) {
    (textInput as number).toFixed(2);
}

updateInput('hello');  // 에러 발생
```

`toFixed()` API는 숫자 데이터에서만 사용할 수 있는 API이기 때문에 문자열 데이터에서는 지원되지 않아 함수가 아니라는 에러가 발생.

타입 단언의 문제점이기도 함. 

**2. 타입 단언을 계속해서 사용해야 한다**

```typescript
function updateInput(textInput: number | string | boolean) {
    (textInput as number).toFixed(2);
    console.log((textInput as string).length);
}
```

매번 특정 타입으로 인식시킬 때 as 키워드를 사용하여 타입을 단언하는 코드를 작성해야 하는 문제가 발생.

### 14.2.3 타입 가드로 문제점 해결하기

```typescript
function updateInput(textInput: number | string | boolean) {
    if (typeof textInput === 'number') {
        textInput.toFixed(2);
        return;
    }
    if (typeof textInput === 'string') {
        console.log(textInput.length);
    	return;
    }
}
```



## 14.3 타입 가드 문법

### 14.3.1 typeof 연산자

```typescript
typeof 10;  			// 'number'
typeof 'hello';  		// 'string'
typeof function() {}  	// 'function'
```

**타입 가드 적용**

```typescript
function printText(text: string | number) {  // 텍스트를 입력받아 콘솔에 출력하는 함수
	if (typeof text= 'string') {  // 문자열이면 앞뒤 공백 제거해서 콘솔에 출력
        	console.log((text.trim());
    }
    if (typeof text = 'number') {  // 이 블록 안에서는 text타입이 number 타입으로 간주됨
            console.log(text);
        }
}
```

### 14.3.2 instanceof 연산자

```typescript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

var captain = new Person('캡틴', 100);
captain instanceof Person;  // true

var hulk = { name: '헐크', age: 79 };
hulk instanceof Person;  // false
```

**프로토타입 체인 구조**

![image-20231107161119096](/img/typescript/14/image-20231107161119096.png)

**타입 가드 적용**

```typescript
class Person {
    name: string;
    age: number;
    
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}

function fetchInfoByProfile(profile: Person | string) {  // 파라미터 값에 따라 다른 정보 데이터를 가져오는 함수
    if (profile instance of Person) {
        // 이 블록 안에서는 profile의 타입이 Person 타입으로 간주됨
        // profile.age 접근 가능 
    }
}
```

### 14.3.3 in 연산자

```typescript
var book = {
    name: '길벗 타입스크립트';
    rank: 1
};

console.log('name' in book);  // true
console.log('address' in book);  // false
```

**타입 가드 적용**

```typescript
interface Book {
    name: string;
    rank: number;
}

interface OnlineLecture {
    name: string;
    url: string;
}

function learnCourse(material: Book | OnlineLecture) {  // material이 취급할 수 있는 속성 : name, rank, url
    if ('url' in material) {
        // material 타입이 OnlineLecture 타입으로 간주됨
    }
    if ('name' in material) {  // 두 인터페이스의 공통 속성인 'name'을 in 연산자로 체크하면??
        material  			   // 특정 타입으로 구분해 주지 않음(타입 가드 역할 못 함)
    }
}
```

